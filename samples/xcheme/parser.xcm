/**
 * A XCHEME Lang parser.
 */
import './lexer';

// Skip
skip ' ' | '\t' | '\v' | '\f' | '\r' | '\n';
skip '/*' & opt repeat (not '*/' then *) & '*/';
skip '//' & opt repeat (not '\n' then *);

// Parser
alias node ARGUMENT_OPERANDS as map {
  <201> REFERENCE as T_IDENTIFIER,
  <202> AUTO      as T_KEYWORDS.AUTO,
  <202> IDENTITY  as T_NUMBER
};

alias node ARGUMENT_LIST as append <auto> next ARGUMENT_OPERANDS & opt (T_SYMBOLS.COMMA & ARGUMENT_LIST);
alias node ARGUMENTS_EXPRESSION as T_SYMBOLS.CHEVRON_OPEN & ARGUMENT_LIST & T_SYMBOLS.CHEVRON_CLOSE;
alias node ARGUMENTS as left append <245> left ARGUMENTS_EXPRESSION;

alias node PARAMETER_LIST as symbol <305> T_IDENTIFIER & opt (T_SYMBOLS.COMMA & PARAMETER_LIST);
alias node PARAMETERS_EXPRESSION as scope (T_SYMBOLS.CHEVRON_OPEN & PARAMETER_LIST & T_SYMBOLS.CHEVRON_CLOSE);

alias node EXPRESSION as OR & opt THEN;
alias node GROUP      as place (T_SYMBOLS.GROUP_OPEN & EXPRESSION & T_SYMBOLS.GROUP_CLOSE);
alias node OPERAND    as MAP | RANGE | REFERENCE | ANY | STRING | GROUP;

alias <S>
node IDENTIFIER as symbol <S> (pivot <200> (T_IDENTIFIER & peek T_KEYWORDS.AS) & T_KEYWORDS.AS & place EXPRESSION);

alias node REFERENCE    as append <201> (T_IDENTIFIER & opt ARGUMENTS);
alias node STRING       as append <203> T_STRING;
alias node ANY          as append <204> (T_KEYWORDS.ANY | T_SYMBOLS.ASTERISK);
alias node RANGE        as place (T_KEYWORDS.FROM & STRING & pivot <205> (T_KEYWORDS.TO & STRING));
alias node MAP          as scope (T_KEYWORDS.MAP & append <206> MAP_MEMBERS);
alias node MEMBERS      as append <207> next ((opt ARGUMENTS & IDENTIFIER <306>) | EXPRESSION) & opt (T_SYMBOLS.COMMA & MEMBERS);
alias node MAP_MEMBERS  as T_SYMBOLS.OPEN_BRACES & MEMBERS & T_SYMBOLS.CLOSE_BRACES;

alias node <216> PLACE_OPERATOR as opt map {
  <215> LEFT  as T_KEYWORDS.LEFT,
  <216> RIGHT as T_KEYWORDS.RIGHT,
  <217> NEXT  as T_KEYWORDS.NEXT
};

alias <D, L, R, N>
node <D> DIRECTIONAL_OPERATOR as opt map {
  <L> LEFT  as T_KEYWORDS.LEFT,
  <R> RIGHT as T_KEYWORDS.RIGHT,
  <N> NEXT  as T_KEYWORDS.NEXT
};

alias node <auto> LEFT_APPEND   as DIRECTIONAL_OPERATOR <219, 218, 219, 220>;
alias node <auto> RIGHT_APPEND  as DIRECTIONAL_OPERATOR <222, 221, 222, 223>;
alias node <auto> NEXT_APPEND   as DIRECTIONAL_OPERATOR <225, 225, 224, 226>;

alias node <auto> LEFT_PREPEND  as DIRECTIONAL_OPERATOR <231, 230, 231, 232>;
alias node <auto> RIGHT_PREPEND as DIRECTIONAL_OPERATOR <228, 229, 228, 230>;
alias node <auto> NEXT_PREPEND  as DIRECTIONAL_OPERATOR <234, 233, 234, 235>;

alias node UNARY as opt repeat append <auto> map {
  <212> NOT         as T_KEYWORDS.NOT,
  <213> OPT         as T_KEYWORDS.OPT,
  <214> REPEAT      as T_KEYWORDS.REPEAT,
  <auto> PLACE      as T_KEYWORDS.PLACE & PLACE_OPERATOR,
  <auto> APPEND     as T_KEYWORDS.APPEND & opt ARGUMENTS & RIGHT_APPEND,
  <auto> L_APPEND   as T_KEYWORDS.LEFT & T_KEYWORDS.APPEND & opt ARGUMENTS & LEFT_APPEND,
  <auto> R_APPEND   as T_KEYWORDS.RIGHT & T_KEYWORDS.APPEND & opt ARGUMENTS & RIGHT_APPEND,
  <auto> N_APPEND   as T_KEYWORDS.NEXT & T_KEYWORDS.APPEND & opt ARGUMENTS & NEXT_APPEND,
  <auto> PREPEND    as T_KEYWORDS.PREPEND & opt ARGUMENTS & RIGHT_PREPEND,
  <auto> L_PREPEND  as T_KEYWORDS.LEFT & T_KEYWORDS.PREPEND & opt ARGUMENTS & LEFT_PREPEND,
  <auto> R_PREPEND  as T_KEYWORDS.RIGHT & T_KEYWORDS.PREPEND & opt ARGUMENTS & RIGHT_PREPEND,
  <auto> N_PREPEND  as T_KEYWORDS.NEXT & T_KEYWORDS.PREPEND & opt ARGUMENTS & NEXT_PREPEND,
  <236> PIVOT       as T_KEYWORDS.PIVOT & opt ARGUMENTS,
  <237> SYMBOL      as T_KEYWORDS.SYMBOL & opt ARGUMENTS,
  <238> SCOPE       as T_KEYWORDS.SCOPE,
  <239> ERROR       as T_KEYWORDS.ERROR & ARGUMENTS,
  <240> HAS         as T_KEYWORDS.HAS & ARGUMENTS,
  <241> SET         as T_KEYWORDS.SET & ARGUMENTS,
  <242> UNCASE      as T_KEYWORDS.UNCASE,
  <243> PEEK        as T_KEYWORDS.PEEK
} & place ACCESS;

alias node ACCESS as OPERAND & opt repeat pivot <244> (T_SYMBOLS.PERIOD & OPERAND);
alias node AND    as UNARY & opt repeat pivot <211> ((T_KEYWORDS.AND | T_SYMBOLS.AMPERSAND) & UNARY);
alias node OR     as AND & opt repeat pivot <210> ((T_KEYWORDS.OR | T_SYMBOLS.VERTICAL_BAR) & AND);
alias node ELSE   as pivot <209> (T_KEYWORDS.ELSE & EXPRESSION);
alias node THEN   as pivot <208> (T_KEYWORDS.THEN & EXPRESSION & opt ELSE);

alias node ALIASES as opt PARAMETERS_EXPRESSION & map {
  <249> TOKEN as T_KEYWORDS.TOKEN & opt ARGUMENTS & IDENTIFIER <303>,
  <250> NODE  as T_KEYWORDS.NODE & opt ARGUMENTS & IDENTIFIER <304>
};

alias node DIRECTIVES as map {
  <246> SKIP   as T_KEYWORDS.SKIP & EXPRESSION,
  <247> TOKEN  as T_KEYWORDS.TOKEN & opt ARGUMENTS & IDENTIFIER <301>,
  <248> NODE   as T_KEYWORDS.NODE & opt ARGUMENTS & IDENTIFIER <302>,
  <auto> ALIAS as T_KEYWORDS.ALIAS & ALIASES
};

alias node MODULES as map {
  <251> IMPORT as T_KEYWORDS.IMPORT & STRING,
  <252> EXPORT as T_KEYWORDS.EXPORT & (append <auto> DIRECTIVES | append <200> T_IDENTIFIER)
};

node <auto> STATEMENTS as (DIRECTIVES | MODULES) & T_SYMBOLS.SEMICOLON;
