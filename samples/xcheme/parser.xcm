/**
 * A XCHEME Lang parser.
 */
import './lexer';

// Skip
skip ' ' | '\t' | '\v' | '\f' | '\r' | '\n';
skip '/*' & opt repeat (not '*/' then *) & '*/';
skip '//' & opt repeat (not '\n' then *);

// Parser
alias node <auto> ARGUMENT_OPERANDS as map {
  <201> T_IDENTIFIER,
  <202> T_NUMBER,
  <202> T_KEYWORDS.AUTO
};

alias node ARGUMENT_LIST as append <auto> next ARGUMENT_OPERANDS & opt (T_SYMBOLS.COMMA & ARGUMENT_LIST);
alias node ARGUMENTS_EXPRESSION as T_SYMBOLS.CHEVRON_OPEN & ARGUMENT_LIST & T_SYMBOLS.CHEVRON_CLOSE;
alias node ARGUMENTS as left append <245> left ARGUMENTS_EXPRESSION;

alias node PARAMETER_LIST as symbol <305> T_IDENTIFIER & opt (T_SYMBOLS.COMMA & PARAMETER_LIST);
alias node PARAMETERS_EXPRESSION as scope (T_SYMBOLS.CHEVRON_OPEN & PARAMETER_LIST & T_SYMBOLS.CHEVRON_CLOSE);

alias node EXPRESSION as OR & opt THEN;
alias node GROUP      as place (T_SYMBOLS.GROUP_OPEN & EXPRESSION & T_SYMBOLS.GROUP_CLOSE);
alias node OPERAND    as MAP | RANGE | REFERENCE | ANY | STRING | GROUP;

alias <SYMBOL>
node IDENTIFIER as symbol <SYMBOL> (pivot <200> (T_IDENTIFIER & peek T_KEYWORDS.AS) & T_KEYWORDS.AS & place EXPRESSION);

alias node REFERENCE    as append <201> (T_IDENTIFIER & opt ARGUMENTS);
alias node STRING       as append <203> T_STRING;
alias node ANY          as append <204> (T_KEYWORDS.ANY | T_SYMBOLS.ASTERISK);
alias node RANGE        as place (T_KEYWORDS.FROM & STRING & pivot <205> (T_KEYWORDS.TO & STRING));
alias node MAP          as scope (T_KEYWORDS.MAP & append <206> MAP_BLOCK);
alias node MAP_ENTRY    as (ARGUMENTS & (IDENTIFIER <306> | place EXPRESSION)) | IDENTIFIER <306> | EXPRESSION;
alias node MAP_MEMBERS  as append <207> next MAP_ENTRY & opt (T_SYMBOLS.COMMA & MAP_MEMBERS);
alias node MAP_BLOCK    as T_SYMBOLS.OPEN_BRACES & MAP_MEMBERS & T_SYMBOLS.CLOSE_BRACES;

alias <DEFAULT, L, R, N>
node <DEFAULT> DIRECTIONAL_OPERATOR as opt map {
  <L> T_KEYWORDS.LEFT,
  <R> T_KEYWORDS.RIGHT,
  <N> T_KEYWORDS.NEXT
};

alias node <auto> PLACE_OPERATOR as DIRECTIONAL_OPERATOR <216, 215, 216, 217>;

alias node <auto> LEFT_APPEND   as DIRECTIONAL_OPERATOR <219, 218, 219, 220>;
alias node <auto> RIGHT_APPEND  as DIRECTIONAL_OPERATOR <222, 221, 222, 223>;
alias node <auto> NEXT_APPEND   as DIRECTIONAL_OPERATOR <225, 225, 224, 226>;

alias node <auto> LEFT_PREPEND  as DIRECTIONAL_OPERATOR <231, 230, 231, 232>;
alias node <auto> RIGHT_PREPEND as DIRECTIONAL_OPERATOR <228, 229, 228, 230>;
alias node <auto> NEXT_PREPEND  as DIRECTIONAL_OPERATOR <234, 233, 234, 235>;

alias node <auto> UNARY as opt repeat append <auto> map {
   <212> T_KEYWORDS.NOT,
   <213> T_KEYWORDS.OPT,
   <214> T_KEYWORDS.REPEAT,
  <auto> T_KEYWORDS.PLACE & PLACE_OPERATOR,
  <auto> T_KEYWORDS.APPEND & opt ARGUMENTS & RIGHT_APPEND,
  <auto> T_KEYWORDS.LEFT & T_KEYWORDS.APPEND & opt ARGUMENTS & LEFT_APPEND,
  <auto> T_KEYWORDS.RIGHT & T_KEYWORDS.APPEND & opt ARGUMENTS & RIGHT_APPEND,
  <auto> T_KEYWORDS.NEXT & T_KEYWORDS.APPEND & opt ARGUMENTS & NEXT_APPEND,
  <auto> T_KEYWORDS.PREPEND & opt ARGUMENTS & RIGHT_PREPEND,
  <auto> T_KEYWORDS.LEFT & T_KEYWORDS.PREPEND & opt ARGUMENTS & LEFT_PREPEND,
  <auto> T_KEYWORDS.RIGHT & T_KEYWORDS.PREPEND & opt ARGUMENTS & RIGHT_PREPEND,
  <auto> T_KEYWORDS.NEXT & T_KEYWORDS.PREPEND & opt ARGUMENTS & NEXT_PREPEND,
   <236> T_KEYWORDS.PIVOT & opt ARGUMENTS,
   <237> T_KEYWORDS.SYMBOL & opt ARGUMENTS,
   <238> T_KEYWORDS.SCOPE,
   <239> T_KEYWORDS.ERROR & ARGUMENTS,
   <240> T_KEYWORDS.HAS & ARGUMENTS,
   <241> T_KEYWORDS.SET & ARGUMENTS,
   <242> T_KEYWORDS.UNCASE,
   <243> T_KEYWORDS.PEEK
} & place ACCESS;

alias node ACCESS as OPERAND & opt repeat pivot <244> (T_SYMBOLS.PERIOD & OPERAND);
alias node AND    as UNARY & opt repeat pivot <211> ((T_KEYWORDS.AND | T_SYMBOLS.AMPERSAND) & UNARY);
alias node OR     as AND & opt repeat pivot <210> ((T_KEYWORDS.OR | T_SYMBOLS.VERTICAL_BAR) & AND);
alias node ELSE   as pivot <209> (T_KEYWORDS.ELSE & EXPRESSION);
alias node THEN   as pivot <208> (T_KEYWORDS.THEN & EXPRESSION & opt ELSE);

alias node <auto> ALIASES as opt PARAMETERS_EXPRESSION & map {
  <249> T_KEYWORDS.TOKEN & opt ARGUMENTS & IDENTIFIER <303>,
  <250> T_KEYWORDS.NODE & opt ARGUMENTS & IDENTIFIER <304>
};

alias node <auto> DIRECTIVES as map {
   <246> T_KEYWORDS.SKIP & EXPRESSION,
   <247> T_KEYWORDS.TOKEN & opt ARGUMENTS & IDENTIFIER <301>,
   <248> T_KEYWORDS.NODE & opt ARGUMENTS & IDENTIFIER <302>,
  <auto> T_KEYWORDS.ALIAS & ALIASES
};

alias node <auto> MODULES as map {
  <251> T_KEYWORDS.IMPORT & STRING,
  <252> T_KEYWORDS.EXPORT & (append <auto> DIRECTIVES | append <200> T_IDENTIFIER)
};

node <auto> STATEMENTS as (DIRECTIVES | MODULES) & T_SYMBOLS.SEMICOLON;
